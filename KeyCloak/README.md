# KeyCloak
KeyCloakを使って、認証サーバーを構築します。
Webシステムをシングルサインオン化します。
KeyCloakを使うとOpenID、SAMLなどによるSSOに対応したWebシステムを簡単に構築できます。また、ユーザの管理機能などもあります。
## Realm
独立した認証と認可の管理領域を指します。一つのKeycloakサーバー上で複数のレルムを作成することができ、それぞれのレルムは独自のユーザー、クライアント、ロール、設定などを持つことができます。
> 「Realm」という言葉は英語で「領域」「領土」「王国」などの意味を持っており、元々は中世ヨーロッパの封建制や王制に関連する文脈で使用されていました。語源としては、古フランス語の「realme」、さらに遡るとラテン語の「regalis」に関連するとされています。ラテン語の「regalis」は「王（rex）」に関連するもの、という意味です。
### Realmを作成する際のガイドライン
* プロジェクト単位: 各プロジェクトに1つのレルムを作成するのが一般的です。
* 環境単位: 開発、テスト、本番環境など、用途ごとに異なるレルムを作成することがあります。
* 組織単位: 組織内の異なる部署やチームが独自のポリシーまたはユーザーデータベースを持つ場合、それぞれに独立したレルムを設定することが有用です。
### レルムの主な機能と設定項目
* ユーザー管理: レルム内でユーザーを作成、編集、削除できます。
* クライアント設定: レルム内で個々のアプリケーションやサービス（クライアント）を設定します。
* ロールと許可: レルム内でユーザーに対するロールや許可を設定できます。
* 認証フロー: レルムごとに独自の認証フロー（例：パスワードポリシー、多要素認証など）を設定できます。
## Clients
Webアプリケーション、モバイルアプリケーション、APIサービス、マイクロサービスなどが含まれます。
### クライアントの主な役割と機能
* 認証・認可: クライアントはユーザーがアクセスする際の認証（ログイン）と認可（権限付与）を行います。
* トークンの発行・検証: クライアントはKeycloakからアクセストークンやIDトークンを受け取り、これを使ってユーザーの身元を確認したり、アクセス権を検証します。
* リダイレクト: OAuth2.0やOpenID Connectの認証フローにおいて、クライアントはユーザーをKeycloakにリダイレクトしてログインさせ、その後、元のアプリケーションにリダイレクトされます。
* 構成・設定: クライアント毎に様々な設定（例：リダイレクトURI、クライアント認証方法、許可されたスコープなど）をKeycloak内で行えます。
* ロールベースアクセス制御: クライアントにはそれぞれ独自のロールを設定することができ、これを用いて細かなアクセス制御を行えます。
* プロトコル対応: Keycloakでは、標準的なプロトコル（OAuth 2.0, OpenID Connect, SAML 2.0等）に基づいてクライアントを設定できます。
### クライアント設定の一例
* Client ID: クライアントを一意に識別するID。
* Root URL: クライアントアプリケーションのルートURL。
* Valid Redirect URIs: 認証後にリダイレクトが許可されるURI。
* Web Origins: CORS（Cross-Origin Resource Sharing）を有効にするオリジン。
* Access Type: クライアントのタイプ（public, confidential, bearer-only）。
* Standard Flow Enabled: Authorization Codeフローの有効/無効。
* Implicit Flow Enabled: Implicitフローの有効/無効。
## Client Scopes
クライアントがリクエストするトークンに含まれるべきクレーム（属性や権限）を決定するための設定です。簡単に言えば、クライアントスコープはアクセストークンやIDトークンにどのような情報を含めるかを制御します。
### クライアントスコープの主な用途
* トークンの内容制御: クライアントが必要とする特定のクレームやロールを含めることができます。
* 再利用性: 同じスコープを複数のクライアントで再利用できます。
* 認証フローのカスタマイズ: スコープによって、どのような認証フローを経るかを制御できます。
### クライアントスコープの種類
* デフォルトスコープ: 新しくクライアントを作成した際に自動的に割り当てられるスコープ。
* オプションスコープ: クライアントが明示的にリクエストを行うことでのみ割り当てられるスコープ。
### クライアントスコープの設定
* スコープ名: スコープの識別名。
* プロトコル: 使用する認証プロトコル（通常はOpenID ConnectまたはSAML）。
* クレーム設定: トークンに含めるクレームの設定。
* マッピング: ロールや他のスコープとのマッピング設定。
### 実際の動作
* ユーザーがログインする際、クライアントは一緒にスコープをリクエストします。
* Keycloakはそのスコープに基づいてトークンを生成し、必要なクレームをそのトークンに含めます。

このように、クライアントスコープはトークンに含まれるデータと、そのデータのアクセスレベルをより細かく制御するための強力なメカニズムを提供します。それにより、セキュリティとデータの粒度のバランスを保つことができます。
## Events
Keycloakの「イベント（Events）」機能は、Keycloak内での重要な動作や操作に関するログを記録・監視するためのものです。この機能はセキュリティ監査やデバッグ、運用監視などに有用です。
### 主なイベントの種類
* ログイン関連: ログイン成功、ログイン失敗、ログアウト、セッション終了など。
* アカウント管理: ユーザー作成、パスワード変更、プロフィール更新など。
* クライアント操作: クライアントの作成、更新、削除など。
* レルム設定: レルムの作成、設定変更、削除など。
* トークン操作: トークンの発行、更新、失効など。
## Roles
### ロールの種類
* レルムロール: レルム全体で有効なロール。これは全てのクライアントで共通です。
* クライアントロール: 特定のクライアントに限定されたロール。これはそのクライアント内でのみ有効です。
* コンポジットロール: 一つ以上の他の基本ロール（レルムロールまたはクライアントロール）を含むロール。
### ロールの設定と管理
* 作成: 管理コンソールの「Roles」セクションから新しいロールを作成できます。
* 割り当て: 作成したロールをユーザーやクライアントに割り当てることができます。
* 属性付与: ロールには追加の属性や設定（例：説明、権限レベルなど）を付与できます。
### ロールとトークン
Keycloakでは、ユーザーが認証に成功すると、そのユーザーに割り当てられたロールがアクセストークン内に埋め込まれます。このトークンを用いて、アプリケーションやサービスはユーザーのアクセス権を判定することができます。



# KeyCloakを起動する
## DokerでKeyCloakを起動する
```powershell
docker pull jboss/keycloak

# 以下のコマンドで、KeyCloakを起動します。
docker run -d -p 8080:8080 -e KEYCLOAK_USER=admin -e KEYCLOAK_PASSWORD=admin --name keycloak jboss/keycloak

# ブラウザでアクセス
http://localhost:8080/auth

```

## Docker ComposeでKeyCloakを起動する
```powershell
# 以下のコマンドで、KeyCloakを起動します。
docker-compose up -d
```
# KeyCloakを使う
## 管理コンソールへのログイン
1. http://localhost:8080/auth
1. admin/adminでログイン
1. Realmの作成
左上のMasterからAdd realmを選択  


# PostgreSQLを使う
```bash
hostname
01896af165e0

psql -h 01896af165e0  -U keycloak
\l
\c keycloak
\dt
```
